/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause) */
#include "inspect.h"
#include <config.h>
#include <stdio.h>
#include <my_string.h>
#include <stdlib.h>
#include <stdarg.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "my_string.h"
#include "coolwidget.h"

#include "stringtools.h"
#include "app_glob.c"

#include "coollocal.h"
#include "remotefs.h"


#define PASSWORD_FILE           "/.cedit/.password"
#define MAX(a, b) ((a) > (b) ? (a) : (b))

extern char *local_home_dir;


struct password_item {
    struct password_item *next;
    char *host;
    int crypto_enabled;
    char *pass;
};

static struct password_item *list_first = NULL;
static int password_loaded = 0;

static void password_item_append (struct password_item **last, struct password_item *p)
{E_
    if (!list_first) {
        assert (*last == NULL);
        *last = list_first = p;
        p->next = NULL;
        return;
    }
    assert (*last != NULL);
    assert ((*last)->next == NULL);
    (*last)->next = p;
    *last = p;
    p->next = NULL;
}

static struct password_item *password_new_item (const char *host, int crypto_enabled, const char *pass)
{E_
    struct password_item *p;
    p = (struct password_item *) malloc (sizeof (struct password_item));
    memset (p, '\0', sizeof (struct password_item));
    p->host = (char *) strdup (host);
    p->crypto_enabled = crypto_enabled;
    p->pass = (char *) strdup (pass);
    return p;
}

static void password_get_config_file (char *out, const char *suffix)
{E_
    snprintf (out, MAX_PATH_LEN, "%s%s%s", local_home_dir, PASSWORD_FILE, suffix);
}

/* returns -1 on error  */
int password_load (void)
{E_
    struct password_item *last = NULL;
    char line[512];
    char host[512];
    char crypto_enabled[512];
    char pass[512];
    char fname[MAX_PATH_LEN];
    FILE *f;

    password_get_config_file (fname, "");

    f = fopen (fname, "r");
    if (!f && errno == ENOENT)
        return 0;
    if (!f)
        return -1;
    for (;;) {
        char *c;
        c = fgets (line, sizeof (line), f);
        if (!c && !feof (f)) {
            fclose (f);
            return 1;
        }
        if (!c)
            break;
        string_chomp (line);
        if (!line[0])
            continue;
        if (line[0] == '#')
            continue;
        pass[0] = '\0';
        if (sscanf (line, "%s %s %s", host, crypto_enabled, pass) < 2)
            continue;
        password_item_append (&last, password_new_item (host, !strcmp (crypto_enabled, "crypto-enabled"), pass));
    }
    fclose (f);
    return 0;
}

static int password_save_ (void)
{E_
    char line[MAX_PATH_LEN];
    char tmpname[MAX_PATH_LEN];
    char fname[MAX_PATH_LEN];
    struct password_item *p;
    int fd;
    password_get_config_file (tmpname, ".tmp");
    password_get_config_file (fname, "");
    fd = open (tmpname, O_CREAT | O_TRUNC | O_WRONLY, 00600);
    if (fd < 0)
        return -1;
    strcpy (line, "# Generated by Cooledit.\n# Format:  <host-ip-address> [crypto-enabled|crypto-disabled] <aes-key>\n\n");
    if (writeall (fd, line, strlen (line)) != strlen (line)) {
        close (fd);
        return -1;
    }
    for (p = list_first; p; p = p->next) {
        snprintf (line, sizeof (line), "%s %s %s\n", p->host, p->crypto_enabled ? "crypto-enabled" : "crypto-disabled", p->pass);
        if (writeall (fd, line, strlen (line)) != strlen (line)) {
            close (fd);
            return -1;
        }
    }
    if (fsync (fd)) {
        close (fd);
        return -1;
    }
    if (close (fd))
        return -1;
    if (rename (tmpname, fname))
        return -1;
    return 0;
}

int password_save (const char *host, int crypto_enabled, const char *pass)
{E_
    struct password_item *p, *last = NULL;
    int found = 0;
    for (p = list_first; p; p = p->next) {
        if (!strcmp (host, p->host)) {
            found++;
            assert (found == 1);
            assert (p->host);
            assert (p->pass);
            free (p->host);
            free (p->pass);
            p->host = (char *) strdup (host);
            p->crypto_enabled = crypto_enabled;
            p->pass = (char *) strdup (pass);
        }
        last = p;
    }
    assert (found == 0 || found == 1);
    assert (!list_first == !last);
    if (!found)
        password_item_append (&last, password_new_item (host, crypto_enabled, pass));
    return password_save_ ();
}

/* return non-zeo on error */
int password_find (const char *host, int *crypto_enabled, char *pass, int pass_len)
{E_
    struct password_item *p;
    for (p = list_first; p; p = p->next) {
        if (!strcmp (host, p->host)) {
            *crypto_enabled = p->crypto_enabled;
            Cstrlcpy (pass, p->pass, pass_len);
            return 0;
        }
    }
    return -1;
}

static int dummy_data;

Window find_mapped_window (Window w);
extern struct look *look;

#define MID_X 20
#define MID_Y 20

char *CAESKeyDialog (const char *ident, Window in, int x, int y, int *crypto_enabled, char *def, const char *heading, const char *label)
{E_
    CWidget *descr;
    char *p = 0;
    int w, h;
    Window win;
    CEvent cwevent;
    CState s;
    char inp_name[256];
    const char *help_text = "\
\
See the man page remotefs(1) and the man page cooledit(1) under FILES,\n\
$HOME/.cedit/.password. The AES key you enter here is the contents of\n\
the file AESKEYFILE produced by remotefs. If you create your own\n\
AESKEYFILE file, it must have sufficient randomness to provide security.\n\
This means the key is a long string of random characters and not a short\n\
easy-to-remember password. When remotefs reads AESKEYFFILE it will test\n\
if sufficient bits of randomness are present, and give an error\n\
otherwise. If remotefs was not started with --force-crypto then you may\n\
select 'Disable crypto' to connect without security: this means anyone\n\
on the network can read any file you load or save.\
\
";

    if (!in) {
	x = MID_X;
	y = MID_Y;
    }
    in = find_mapped_window (in);
    CTextSize (&w, &h, label);
    w = 64 * FONT_MEAN_WIDTH;
    CBackupState (&s);
    CDisable ("*");
    win = CDrawHeadedDialog ("_inputdialog", in, x, y, heading);
    CSetToolHint ("_inputdialog", help_text);
    CGetHintPos (&x, &y);
    descr = CDrawText ("_inputdialog.descr", win, x, y, "%s", label);
    CSetSize (descr, MAX (w, descr->width), descr->height);
    CGetHintPos (0, &y);
    CDrawButton ("_inputdialog.nocrypto", win, x, y, w, AUTO_HEIGHT, " Disable crypto and connect without security ");
    CSetToolHint ("_inputdialog.nocrypto", help_text);
    CGetHintPos (0, &y);
    strcpy (inp_name, ident);
    inp_name[20] = '\0';
    strcat (inp_name, ".inpt_dlg");
    CDrawTextInputP (inp_name, win, x, y, w, AUTO_HEIGHT, 255, def)->options |= TEXTINPUT_NOHISTORY;
    CSetToolHint (inp_name, help_text);
    CGetHintPos (0, &y);
    (*look->draw_tick_ok_button) ("_inputdialog.clickhere", win, (w + 16) / 4 - 22, y);
    (*look->draw_cross_cancel_button) ("_inputdialog.crosshere", win, 3 * (w + 16) / 4 - 22, y);
    CSetSizeHintPos ("_inputdialog");
    CMapDialog ("_inputdialog");
    CFocus (CIdent (inp_name));
    CIdent ("_inputdialog")->position = WINDOW_ALWAYS_RAISED;
/* handler : */
    do {
	CNextEvent (NULL, &cwevent);
	if (cwevent.command == CK_Cancel || !strcmp (cwevent.ident, "_inputdialog.crosshere"))
	    goto fin;
	if (!strcmp (cwevent.ident, "_inputdialog.nocrypto")) {
            *crypto_enabled = 0;
	    break;
        }
	if (cwevent.command == CK_Enter)
	    break;
	if (!CIdent ("_inputdialog"))
	    goto fin;
    } while (strcmp (cwevent.ident, "_inputdialog.clickhere"));
    p = (char *) strdup (CIdent (inp_name)->text.data);

  fin:
    CDestroyWidget ("_inputdialog");
    CRestoreState (&s);
    return p;
}

static int contains_whitespace (const char *pass_)
{E_
    const unsigned char *p;
    p = (const unsigned char *) pass_;
    while (*p)
        if (*p++ <= ' ')
            return 1;
    return 0;
}

static enum remotfs_password_return password_remotfs_password_cb_ (void *user_data, int again, const char *host, int *crypto_enabled_, unsigned char *pass_, const char *user_msg, char *errmsg)
{E_
    char pass[REMOTEFS_MAX_PASSWORD_LEN] = "";
    int crypto_enabled = 1;
    char *s;
    int found;

    *crypto_enabled_ = 1;

    if (!password_loaded) {
        password_loaded = 1;
        if (password_load ()) {
            CErrorDialog (0, 20, 20, "Error Loading Passwords", " Error Loading Passwords: ~%s: %s", PASSWORD_FILE, get_sys_error (""));
        }
    }

    assert (user_data == &dummy_data);
    found = !password_find (host, &crypto_enabled, (char *) pass, REMOTEFS_MAX_PASSWORD_LEN);
    if (!again && found) {
        *crypto_enabled_ = crypto_enabled;
        strcpy ((char *) pass_, pass);
        return REMOTFS_PASSWORD_RETURN_SUCCESS;
    }

    strcpy (pass, (const char *) pass_);

    for (;;) {
        char msg[256];
        if (user_msg && *user_msg)
            snprintf (msg, sizeof (msg), " [%s] \n\n Enter a strong AES key for host %s.\n Whitespace is not allowed : ", user_msg, host);
        else
            snprintf (msg, sizeof (msg), " Enter a strong AES key for host %s.\n Whitespace is not allowed : ", host);
        crypto_enabled = 1;
        s = CAESKeyDialog ("aeskey", 0, 0, 0, &crypto_enabled, pass, " AES Key ", msg);
        if (!s) {
            strcpy (errmsg, "connection canceled by the user");
            return REMOTFS_PASSWORD_RETURN_USERCANCEL;
        }
        strcpy ((char *) pass, s);
        free (s);
        if (!crypto_enabled && contains_whitespace (pass)) {
            pass[0] = '\0';
        } else if (contains_whitespace (pass)) {
            CErrorDialog (0, 20, 20, "Password Error", " Password Error: Whitespace characters are not allowed. ");
            continue;
        }
        break;
    }

    if (password_save (host, crypto_enabled, pass))
        CErrorDialog (0, 20, 20, "Error Saving Passwords", " Error Saving Passwords: ~%s: %s", PASSWORD_FILE, get_sys_error (""));

    *crypto_enabled_ = crypto_enabled;
    strcpy ((char *) pass_, pass);

    return REMOTFS_PASSWORD_RETURN_SUCCESS;
}

static enum remotfs_password_return password_remotfs_password_cb (void *user_data, int again, const char *host, int *crypto_enabled_, unsigned char *pass_, const char *user_msg, char *errmsg)
{E_
    enum remotfs_password_return r;
    struct hint_pos *h;
    h = CPushHintPos ();
    r = password_remotfs_password_cb_ (user_data, again, host, crypto_enabled_, pass_, user_msg, errmsg);
    CPopHintPos (h);
    return r;
}

void password_init (void)
{E_
    remotefs_set_password_cb (password_remotfs_password_cb, &dummy_data);
}







